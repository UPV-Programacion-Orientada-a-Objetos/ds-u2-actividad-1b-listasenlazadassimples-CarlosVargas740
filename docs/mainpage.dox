/**
 * @mainpage Sistema de Gestión Polimórfica de Sensores para IoT
 * 
 * @section intro_sec Introducción
 * 
 * Este sistema implementa una solución completa de monitoreo de sensores IoT
 * utilizando conceptos avanzados de Programación Orientada a Objetos:
 * 
 * - **Polimorfismo**: Uso de clases abstractas y métodos virtuales
 * - **Templates**: Listas enlazadas genéricas para múltiples tipos de datos
 * - **Gestión de Memoria**: Implementación de la Regla de los Tres
 * - **Integración Hardware**: Comunicación con Arduino por serial
 * 
 * @section features_sec Características Principales
 * 
 * - Soporte para múltiples tipos de sensores (Temperatura, Presión, Vibración)
 * - Almacenamiento dinámico con listas enlazadas
 * - Procesamiento polimórfico de datos
 * - Simulación de comunicación serial con Arduino
 * - Sistema completamente redistribuible con CMake
 * 
 * @section usage_sec Uso Básico
 * 
 * @code
 * // Crear lista de gestión polimórfica
 * ListaGestion listaGestion;
 * 
 * // Crear sensores de diferentes tipos
 * SensorBase* temp = new SensorTemperatura("T-001");
 * SensorBase* pres = new SensorPresion("P-105");
 * 
 * // Agregar a la lista
 * listaGestion.agregarSensor(temp);
 * listaGestion.agregarSensor(pres);
 * 
 * // Registrar lecturas
 * temp->registrarLectura("25.5");
 * pres->registrarLectura("1013");
 * 
 * // Procesar todos (polimorfismo)
 * listaGestion.procesarTodosSensores();
 * @endcode
 * 
 * @section install_sec Instalación
 * 
 * @subsection step1 Paso 1: Clonar el repositorio
 * @code
 * git clone [URL_DEL_REPOSITORIO]
 * cd sistema-sensores-iot
 * @endcode
 * 
 * @subsection step2 Paso 2: Compilar con CMake
 * @code
 * mkdir build && cd build
 * cmake ..
 * make
 * @endcode
 * 
 * @subsection step3 Paso 3: Ejecutar
 * @code
 * ./bin/sistema_sensores_iot
 * @endcode
 * 
 * @section arch_sec Arquitectura
 * 
 * El sistema está organizado en los siguientes módulos:
 * 
 * - @ref SensorBase "Módulo de Sensores" - Jerarquía polimórfica de sensores
 * - @ref ListaSensor "Módulo de Almacenamiento" - Listas enlazadas genéricas
 * - @ref ListaGestion "Módulo de Gestión" - Control polimórfico de sensores
 * - @ref SimuladorSerial "Módulo de Comunicación" - Interfaz con Arduino
 * 
 * @section author_sec Autor
 * 
 * **Carlos Vargas**  
 * Programación Orientada a Objetos  
 * Universidad Politécnica de Valencia  
 * Octubre 2025
 * 
 * @section license_sec Licencia
 * 
 * Este proyecto es de uso educativo para la asignatura de POO.
 */

/**
 * @page examples Ejemplos de Uso
 * 
 * @section ex1 Ejemplo 1: Creación de Sensores
 * 
 * @code
 * #include "SensorTemperatura.h"
 * #include "SensorPresion.h"
 * 
 * int main() {
 *     // Crear sensores
 *     SensorBase* temp = new SensorTemperatura("T-001");
 *     SensorBase* pres = new SensorPresion("P-105");
 *     
 *     // Usar polimorfismo
 *     temp->registrarLectura("25.5");
 *     temp->procesarLectura();
 *     
 *     // Liberar memoria
 *     delete temp;
 *     delete pres;
 *     
 *     return 0;
 * }
 * @endcode
 * 
 * @section ex2 Ejemplo 2: Uso de Templates
 * 
 * @code
 * #include "ListaSensor.h"
 * 
 * int main() {
 *     // Lista para floats
 *     ListaSensor<float> temperaturas;
 *     temperaturas.insertarAlFinal(25.5f);
 *     temperaturas.insertarAlFinal(26.3f);
 *     
 *     float promedio = temperaturas.calcularPromedio();
 *     
 *     // Lista para ints
 *     ListaSensor<int> presiones;
 *     presiones.insertarAlFinal(1013);
 *     presiones.insertarAlFinal(1015);
 *     
 *     int promedioPresion = presiones.calcularPromedio();
 *     
 *     return 0;
 * }
 * @endcode
 * 
 * @section ex3 Ejemplo 3: Gestión Polimórfica
 * 
 * @code
 * #include "ListaGestion.h"
 * 
 * int main() {
 *     ListaGestion lista;
 *     
 *     // Agregar diferentes tipos de sensores
 *     lista.agregarSensor(new SensorTemperatura("T-001"));
 *     lista.agregarSensor(new SensorPresion("P-105"));
 *     lista.agregarSensor(new SensorVibracion("V-201"));
 *     
 *     // Procesar todos polimórficamente
 *     lista.procesarTodosSensores();
 *     
 *     // La memoria se libera automáticamente al destruir 'lista'
 *     return 0;
 * }
 * @endcode
 */

/**
 * @page concepts Conceptos Avanzados
 * 
 * @section poly Polimorfismo
 * 
 * El polimorfismo permite tratar objetos de diferentes clases derivadas
 * de manera uniforme a través de punteros a la clase base:
 * 
 * @code
 * SensorBase* sensor = new SensorTemperatura("T-001");
 * sensor->procesarLectura();  // Llama a SensorTemperatura::procesarLectura()
 * @endcode
 * 
 * @section templates Templates
 * 
 * Los templates permiten escribir código genérico que funciona con
 * múltiples tipos de datos:
 * 
 * @code
 * template <typename T>
 * class ListaSensor {
 *     Nodo<T>* inicio;
 *     // ...
 * };
 * @endcode
 * 
 * @section rule3 Regla de los Tres
 * 
 * Cuando una clase maneja recursos dinámicos, debe implementar:
 * 
 * 1. **Destructor**: Libera la memoria
 * 2. **Constructor de copia**: Realiza copia profunda
 * 3. **Operador de asignación**: Evita copias superficiales
 * 
 * @code
 * class MiClase {
 *     ~MiClase();                           // Destructor
 *     MiClase(const MiClase&);              // Constructor de copia
 *     MiClase& operator=(const MiClase&);   // Operador de asignación
 * };
 * @endcode
 * 
 * @section virt_dest Destructores Virtuales
 * 
 * **Crítico para polimorfismo**: El destructor de la clase base
 * debe ser virtual para garantizar la correcta liberación de memoria:
 * 
 * @code
 * class Base {
 *     virtual ~Base() { }  // ¡DEBE ser virtual!
 * };
 * 
 * class Derivada : public Base {
 *     ~Derivada() override { }  // Se llamará correctamente
 * };
 * @endcode
 */
